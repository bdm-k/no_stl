#pragma once

#include <cstddef>
#include <type_traits>
#include <new>

namespace no_stl
{

template <typename T>
struct allocator
{
  using value_type = T;
  using size_type = std::size_t;
  using difference_type = std::ptrdiff_t;
  using propagate_on_container_move_assignment = std::true_type;
  using is_always_equal = std::true_type;

  // constructors
  constexpr allocator() noexcept = default;
  constexpr allocator(const allocator &) noexcept = default;
  template <typename U>
  constexpr allocator(const allocator<U> &) noexcept
  {
  }

  // destructor
  constexpr ~allocator() = default;

  [[nodiscard]]
  constexpr T * allocate(size_type n)
  {
    std::size_t count;
    if (__builtin_mul_overflow(sizeof(T), n, &count)) {
      return nullptr;
    }

    void * ptr = ::operator new(count, std::align_val_t{alignof(T)}, std::nothrow);
    return static_cast<T *>(ptr);
  }

  constexpr void deallocate(T * p, size_type n)
  {
    std::size_t count;
    if (__builtin_mul_overflow(sizeof(T), n, &count)) {
      return;
    }

    ::operator delete(p, count);
  }
};

template <typename T1, typename T2>
constexpr bool operator==(const allocator<T1> &, const allocator<T2> &) noexcept
{
  return true;
}

}  // namespace no_stl
