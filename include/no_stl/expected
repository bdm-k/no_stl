#pragma once

#include <no_stl/__expected/unexpected.hpp>
#include <no_stl/optional>

#include <algorithm>
#include <cstdint>
#include <functional>
#include <new>
#include <type_traits>
#include <utility>

namespace no_stl
{

namespace detail
{

template <typename T>
struct is_expected;

}  // namespace detail

template <typename T, typename E>
class expected
{
  static_assert(!std::is_array_v<T>);
  static_assert(!std::is_reference_v<T>);
  static_assert(detail::unexpected_eligible<E>);

  template <typename, typename>
  friend class expected;

  static constexpr size_t storage_size = std::max(sizeof(T), sizeof(E));
  static constexpr size_t storage_alignment = std::max(alignof(T), alignof(E));

  alignas(storage_alignment) uint8_t storage_[storage_size];
  bool has_val_;

  constexpr T * value_ptr() noexcept { return std::launder(reinterpret_cast<T *>(storage_)); }
  constexpr const T * value_ptr() const noexcept
  {
    return std::launder(reinterpret_cast<const T *>(storage_));
  }
  constexpr E * error_ptr() noexcept { return std::launder(reinterpret_cast<E *>(storage_)); }
  constexpr const E * error_ptr() const noexcept
  {
    return std::launder(reinterpret_cast<const E *>(storage_));
  }

  template <typename... Args>
  constexpr void reinit_as_value(Args &&... args)
  {
    error_ptr()->~E();
    ::new (static_cast<void *>(storage_)) T(std::forward<Args>(args)...);
    has_val_ = true;
  }
  template <typename... Args>
  constexpr void reinit_as_error(Args &&... args)
  {
    value_ptr()->~T();
    ::new (static_cast<void *>(storage_)) E(std::forward<Args>(args)...);
    has_val_ = false;
  }

public:
  using value_type = T;
  using error_type = E;
  using unexpect_type = unexpected<E>;

  template <typename U>
  using rebind = expected<U, error_type>;

  // constructors
  constexpr expected()
    requires std::is_default_constructible_v<T>
  : has_val_(true)
  {
    ::new (static_cast<void *>(storage_)) T();
  }
  constexpr expected(const expected & other)
    requires std::is_copy_constructible_v<T> && std::is_copy_constructible_v<E>
  : has_val_(other.has_val_)
  {
    if (has_val_) {
      ::new (static_cast<void *>(storage_)) T(*other.value_ptr());
    } else {
      ::new (static_cast<void *>(storage_)) E(*other.error_ptr());
    }
  }
  constexpr expected(expected && other) noexcept(
    std::is_nothrow_move_constructible_v<T> && std::is_nothrow_move_constructible_v<E>)
    requires std::is_move_constructible_v<T> && std::is_move_constructible_v<E>
  : has_val_(other.has_val_)
  {
    if (has_val_) {
      ::new (static_cast<void *>(storage_)) T(std::move(*other.value_ptr()));
    } else {
      ::new (static_cast<void *>(storage_)) E(std::move(*other.error_ptr()));
    }
  }
  template <typename U, typename G>
  constexpr explicit(!std::is_convertible_v<const U &, T> || !std::is_convertible_v<const G &, E>)
    expected(const expected<U, G> & other)
    requires std::is_constructible_v<T, const U &> && std::is_constructible_v<E, const G &> &&
             (std::is_same_v<std::remove_cv_t<T>, bool> ||
              (!std::is_constructible_v<T, expected<U, G> &>) &&
                (!std::is_constructible_v<T, expected<U, G>>) &&
                (!std::is_constructible_v<T, const expected<U, G> &>) &&
                (!std::is_constructible_v<T, const expected<U, G>>) &&
                (!std::is_convertible_v<expected<U, G> &, T>) &&
                (!std::is_convertible_v<expected<U, G>, T>) &&
                (!std::is_convertible_v<const expected<U, G> &, T>) &&
                (!std::is_convertible_v<const expected<U, G>, T>)) &&
             (!std::is_constructible_v<unexpected<E>, expected<U, G> &>) &&
             (!std::is_constructible_v<unexpected<E>, expected<U, G>>) &&
             (!std::is_constructible_v<unexpected<E>, const expected<U, G> &>) &&
             (!std::is_constructible_v<unexpected<E>, const expected<U, G>>)
  : has_val_(other.has_val_)
  {
    if (has_val_) {
      ::new (static_cast<void *>(storage_)) T(*other.value_ptr());
    } else {
      ::new (static_cast<void *>(storage_)) E(*other.error_ptr());
    }
  }
  template <typename U, typename G>
  constexpr explicit(!std::is_convertible_v<U, T> || !std::is_convertible_v<G, E>)
    expected(expected<U, G> && other)
    requires std::is_constructible_v<T, U> && std::is_constructible_v<E, G> &&
             (std::is_same_v<std::remove_cv_t<T>, bool> ||
              (!std::is_constructible_v<T, expected<U, G> &>) &&
                (!std::is_constructible_v<T, expected<U, G>>) &&
                (!std::is_constructible_v<T, const expected<U, G> &>) &&
                (!std::is_constructible_v<T, const expected<U, G>>) &&
                (!std::is_convertible_v<expected<U, G> &, T>) &&
                (!std::is_convertible_v<expected<U, G>, T>) &&
                (!std::is_convertible_v<const expected<U, G> &, T>) &&
                (!std::is_convertible_v<const expected<U, G>, T>)) &&
             (!std::is_constructible_v<unexpected<E>, expected<U, G> &>) &&
             (!std::is_constructible_v<unexpected<E>, expected<U, G>>) &&
             (!std::is_constructible_v<unexpected<E>, const expected<U, G> &>) &&
             (!std::is_constructible_v<unexpected<E>, const expected<U, G>>)
  : has_val_(other.has_val_)
  {
    if (has_val_) {
      ::new (static_cast<void *>(storage_)) T(std::move(*other.value_ptr()));
    } else {
      ::new (static_cast<void *>(storage_)) E(std::move(*other.error_ptr()));
    }
  }
  template <typename U = std::remove_cv_t<T>>
  constexpr explicit(!std::is_convertible_v<U, T>) expected(U && v)
    requires std::is_constructible_v<T, U> &&
             (!std::is_same_v<std::remove_cvref_t<U>, std::in_place_t>) &&
             (!std::is_same_v<std::remove_cvref_t<U>, expected<T, E>>) &&
             (!detail::is_unexpected_v<std::remove_cvref_t<U>>) &&
             (!std::is_same_v<std::remove_cv_t<T>, bool> ||
              !detail::is_expected<std::remove_cvref_t<U>>::value)
  : has_val_(true)
  {
    ::new (static_cast<void *>(storage_)) T(std::forward<U>(v));
  }
  template <typename G>
  constexpr explicit(!std::is_convertible_v<const G &, E>) expected(const unexpected<G> & e)
    requires std::is_constructible_v<E, const G &>
  : has_val_(false)
  {
    ::new (static_cast<void *>(storage_)) E(e.error());
  }
  template <typename G>
  constexpr explicit(!std::is_convertible_v<G, E>) expected(unexpected<G> && e)
    requires std::is_constructible_v<E, G>
  : has_val_(false)
  {
    ::new (static_cast<void *>(storage_)) E(std::move(e).error());
  }
  template <typename... Args>
  constexpr explicit expected(std::in_place_t, Args &&... args)
    requires std::is_constructible_v<T, Args...>
  : has_val_(true)
  {
    ::new (static_cast<void *>(storage_)) T(std::forward<Args>(args)...);
  }
  template <typename U, typename... Args>
  constexpr explicit expected(std::in_place_t, std::initializer_list<U> ilist, Args &&... args)
    requires std::is_constructible_v<T, std::initializer_list<U> &, Args...>
  : has_val_(true)
  {
    ::new (static_cast<void *>(storage_)) T(ilist, std::forward<Args>(args)...);
  }
  template <typename... Args>
  constexpr explicit expected(unexpect_t, Args &&... args)
    requires std::is_constructible_v<E, Args...>
  : has_val_(false)
  {
    ::new (static_cast<void *>(storage_)) E(std::forward<Args>(args)...);
  }
  template <typename U, typename... Args>
  constexpr explicit expected(unexpect_t, std::initializer_list<U> ilist, Args &&... args)
    requires std::is_constructible_v<E, std::initializer_list<U> &, Args...>
  : has_val_(false)
  {
    ::new (static_cast<void *>(storage_)) E(ilist, std::forward<Args>(args)...);
  }

  // destructor
  constexpr ~expected()
  {
    if (has_val_) {
      value_ptr()->~T();
    } else {
      error_ptr()->~E();
    }
  }

  // assignment
  constexpr expected & operator=(const expected & other)
    requires std::is_copy_constructible_v<T> && std::is_copy_assignable_v<T> &&
             std::is_copy_constructible_v<E> && std::is_copy_assignable_v<E>
  {
    if (this != &other) {
      if (has_val_ && other.has_val_) {
        *value_ptr() = *other.value_ptr();
      } else if (!has_val_ && !other.has_val_) {
        *error_ptr() = *other.error_ptr();
      } else if (has_val_) {
        reinit_as_error(*other.error_ptr());
      } else {
        reinit_as_value(*other.value_ptr());
      }
    }
    return *this;
  }
  constexpr expected & operator=(expected && other) noexcept(
    std::is_nothrow_move_constructible_v<T> && std::is_nothrow_move_assignable_v<T> &&
    std::is_nothrow_move_constructible_v<E> && std::is_nothrow_move_assignable_v<E>)
    requires std::is_move_constructible_v<T> && std::is_move_assignable_v<T> &&
             std::is_move_constructible_v<E> && std::is_move_assignable_v<E>
  {
    if (this != &other) {
      if (has_val_ && other.has_val_) {
        *value_ptr() = std::move(*other.value_ptr());
      } else if (!has_val_ && !other.has_val_) {
        *error_ptr() = std::move(*other.error_ptr());
      } else if (has_val_) {
        reinit_as_error(std::move(*other.error_ptr()));
      } else {
        reinit_as_value(std::move(*other.value_ptr()));
      }
    }
    return *this;
  }
  template <typename U = std::remove_cv_t<T>>
  constexpr expected & operator=(U && v)
    requires(!std::is_same_v<expected, std::remove_cvref_t<U>>) &&
            (!detail::is_unexpected_v<std::remove_cvref_t<U>>) && std::is_constructible_v<T, U> &&
            std::is_assignable_v<T &, U>
  {
    if (has_val_) {
      *value_ptr() = std::forward<U>(v);
    } else {
      reinit_as_value(std::forward<U>(v));
    }
    return *this;
  }
  template <typename G>
  constexpr expected & operator=(const unexpected<G> & e)
    requires std::is_constructible_v<E, const G &> && std::is_assignable_v<E &, const G &>
  {
    if (has_val_) {
      reinit_as_error(e.error());
    } else {
      *error_ptr() = e.error();
    }
    return *this;
  }
  template <typename G>
  constexpr expected & operator=(unexpected<G> && e)
    requires std::is_constructible_v<E, G> && std::is_assignable_v<E &, G>
  {
    if (has_val_) {
      reinit_as_error(std::move(e).error());
    } else {
      *error_ptr() = std::move(e).error();
    }
    return *this;
  }

  // observers
  constexpr const T * operator->() const noexcept { return value_ptr(); }
  constexpr T * operator->() noexcept { return value_ptr(); }
  constexpr const T & operator*() const & noexcept { return *value_ptr(); }
  constexpr T & operator*() & noexcept { return *value_ptr(); }
  constexpr const T && operator*() const && noexcept = delete;
  constexpr T && operator*() && noexcept { return std::move(*value_ptr()); }
  constexpr explicit operator bool() const noexcept { return has_val_; }
  constexpr bool has_value() const noexcept { return has_val_; }
  constexpr const T & value() const & noexcept { return *value_ptr(); }
  constexpr T & value() & noexcept { return *value_ptr(); }
  constexpr const T && value() const && noexcept = delete;
  constexpr T && value() && noexcept { return std::move(*value_ptr()); }
  constexpr const E & error() const & noexcept { return *error_ptr(); }
  constexpr E & error() & noexcept { return *error_ptr(); }
  constexpr const E && error() const && noexcept = delete;
  constexpr E && error() && noexcept { return std::move(*error_ptr()); }
  template <typename U = std::remove_cv_t<T>>
  constexpr T value_or(U && default_value) const &
  {
    return has_val_ ? *value_ptr() : static_cast<T>(std::forward<U>(default_value));
  }
  template <typename U = std::remove_cv_t<T>>
  constexpr T value_or(U && default_value) &&
  {
    return has_val_ ? std::move(*value_ptr()) : static_cast<T>(std::forward<U>(default_value));
  }
  template <typename G = E>
  constexpr E error_or(G && default_value) const &
  {
    return has_val_ ? std::forward<G>(default_value) : *error_ptr();
  }
  template <typename G = E>
  constexpr E error_or(G && default_value) &&
  {
    return has_val_ ? std::forward<G>(default_value) : std::move(*error_ptr());
  }

  // monadic operations
  template <typename F>
  constexpr auto and_then(F && f) const &
    requires std::is_constructible_v<E, decltype(error())>
  {
    using result_t = std::remove_cvref_t<std::invoke_result_t<F, decltype(value())>>;
    if (has_val_) {
      return std::invoke(std::forward<F>(f), *value_ptr());
    }
    return result_t(unexpect, *error_ptr());
  }
  template <typename F>
  constexpr auto and_then(F && f) &
    requires std::is_constructible_v<E, decltype(error())>
  {
    using result_t = std::remove_cvref_t<std::invoke_result_t<F, decltype(value())>>;
    if (has_val_) {
      return std::invoke(std::forward<F>(f), *value_ptr());
    }
    return result_t(unexpect, *error_ptr());
  }
  template <typename F>
  constexpr auto and_then(F && f) const && = delete;
  template <typename F>
  constexpr auto and_then(F && f) &&
    requires std::is_constructible_v<E, decltype(std::move(error()))>
  {
    using result_t = std::remove_cvref_t<std::invoke_result_t<F, decltype(std::move(value()))>>;
    if (has_val_) {
      return std::invoke(std::forward<F>(f), std::move(*value_ptr()));
    }
    return result_t(unexpect, std::move(*error_ptr()));
  }

  template <typename F>
  constexpr auto transform(F && f) const &
    requires std::is_constructible_v<E, decltype(error())>
  {
    using result_t = std::remove_cv_t<std::invoke_result_t<F, decltype(value())>>;
    if (has_val_) {
      if constexpr (std::is_void_v<result_t>) {
        std::invoke(std::forward<F>(f), *value_ptr());
        return expected<result_t, E>();
      } else {
        return expected<result_t, E>(std::in_place, std::invoke(std::forward<F>(f), *value_ptr()));
      }
    }
    return expected<result_t, E>(unexpect, *error_ptr());
  }
  template <typename F>
  constexpr auto transform(F && f) &
    requires std::is_constructible_v<E, decltype(error())>
  {
    using result_t = std::remove_cv_t<std::invoke_result_t<F, decltype(value())>>;
    if (has_val_) {
      if constexpr (std::is_void_v<result_t>) {
        std::invoke(std::forward<F>(f), *value_ptr());
        return expected<result_t, E>();
      } else {
        return expected<result_t, E>(std::in_place, std::invoke(std::forward<F>(f), *value_ptr()));
      }
    }
    return expected<result_t, E>(unexpect, *error_ptr());
  }
  template <typename F>
  constexpr auto transform(F && f) const && = delete;
  template <typename F>
  constexpr auto transform(F && f) &&
    requires std::is_constructible_v<E, decltype(std::move(error()))>
  {
    using result_t = std::remove_cv_t<std::invoke_result_t<F, decltype(std::move(value()))>>;
    if (has_val_) {
      if constexpr (std::is_void_v<result_t>) {
        std::invoke(std::forward<F>(f), std::move(*value_ptr()));
        return expected<result_t, E>();
      } else {
        return expected<result_t, E>(
          std::in_place, std::invoke(std::forward<F>(f), std::move(*value_ptr())));
      }
    }
    return expected<result_t, E>(unexpect, std::move(*error_ptr()));
  }

  template <typename F>
  constexpr auto or_else(F && f) const &
    requires std::is_constructible_v<T, decltype(value())>
  {
    using result_t = std::remove_cvref_t<std::invoke_result_t<F, decltype(error())>>;
    if (has_val_) {
      return result_t(std::in_place, *value_ptr());
    }
    return std::invoke(std::forward<F>(f), *error_ptr());
  }
  template <typename F>
  constexpr auto or_else(F && f) &
    requires std::is_constructible_v<T, decltype(value())>
  {
    using result_t = std::remove_cvref_t<std::invoke_result_t<F, decltype(error())>>;
    if (has_val_) {
      return result_t(std::in_place, *value_ptr());
    }
    return std::invoke(std::forward<F>(f), *error_ptr());
  }
  template <typename F>
  constexpr auto or_else(F && f) const && = delete;
  template <typename F>
  constexpr auto or_else(F && f) &&
    requires std::is_constructible_v<T, decltype(std::move(value()))>
  {
    using result_t = std::remove_cvref_t<std::invoke_result_t<F, decltype(std::move(error()))>>;
    if (has_val_) {
      return result_t(std::in_place, std::move(*value_ptr()));
    }
    return std::invoke(std::forward<F>(f), std::move(*error_ptr()));
  }

  template <typename F>
  constexpr auto transform_error(F && f) const &
    requires std::is_constructible_v<T, decltype(value())>
  {
    using result_t = std::remove_cv_t<std::invoke_result_t<F, decltype(error())>>;
    if (has_val_) {
      return expected<T, result_t>(std::in_place, *value_ptr());
    }
    return expected<T, result_t>(unexpect, std::invoke(std::forward<F>(f), *error_ptr()));
  }
  template <typename F>
  constexpr auto transform_error(F && f) &
    requires std::is_constructible_v<T, decltype(value())>
  {
    using result_t = std::remove_cv_t<std::invoke_result_t<F, decltype(error())>>;
    if (has_val_) {
      return expected<T, result_t>(std::in_place, *value_ptr());
    }
    return expected<T, result_t>(unexpect, std::invoke(std::forward<F>(f), *error_ptr()));
  }
  template <typename F>
  constexpr auto transform_error(F && f) const && = delete;
  template <typename F>
  constexpr auto transform_error(F && f) &&
    requires std::is_constructible_v<T, decltype(std::move(value()))>
  {
    using result_t = std::remove_cv_t<std::invoke_result_t<F, decltype(std::move(error()))>>;
    if (has_val_) {
      return expected<T, result_t>(std::in_place, std::move(*value_ptr()));
    }
    return expected<T, result_t>(
      unexpect, std::invoke(std::forward<F>(f), std::move(*error_ptr())));
  }

  // modifiers
  template <typename... Args>
  constexpr T & emplace(Args &&... args) noexcept
    requires std::is_nothrow_constructible_v<T, Args...>
  {
    if (has_val_) {
      value_ptr()->~T();
    } else {
      error_ptr()->~E();
    }
    ::new (static_cast<void *>(storage_)) T(std::forward<Args>(args)...);
    has_val_ = true;
    return *value_ptr();
  }
  template <typename U, typename... Args>
  constexpr T & emplace(std::initializer_list<U> ilist, Args &&... args) noexcept
    requires std::is_nothrow_constructible_v<T, std::initializer_list<U> &, Args...>
  {
    if (has_val_) {
      value_ptr()->~T();
    } else {
      error_ptr()->~E();
    }
    ::new (static_cast<void *>(storage_)) T(ilist, std::forward<Args>(args)...);
    has_val_ = true;
    return *value_ptr();
  }

  constexpr void swap(expected & other) noexcept(
    std::is_nothrow_move_constructible_v<T> && std::is_nothrow_swappable_v<T> &&
    std::is_nothrow_move_constructible_v<E> && std::is_nothrow_swappable_v<E>)
    requires std::is_swappable_v<T> && std::is_swappable_v<E> && std::is_move_constructible_v<T> &&
             std::is_move_constructible_v<E>
  {
    if (has_val_ && other.has_val_) {
      std::swap(*value_ptr(), *other.value_ptr());
    } else if (!has_val_ && !other.has_val_) {
      std::swap(*error_ptr(), *other.error_ptr());
    } else if (has_val_) {
      E temp(std::move(*other.error_ptr()));
      other = std::move(*this);
      *this = std::move(temp);
    } else {
      other.swap(*this);
    }
  }

  // non-member functions
  template <typename T2, typename E2>
    requires(!std::is_void_v<T2>)
  friend constexpr bool operator==(const expected & lhs, const expected<T2, E2> & rhs)
  {
    if (lhs.has_val_ && rhs.has_val_) {
      return *lhs.value_ptr() == *rhs.value_ptr();
    } else if (!lhs.has_val_ && !rhs.has_val_) {
      return *lhs.error_ptr() == *rhs.error_ptr();
    }
    return false;
  }
  template <typename E2>
  friend constexpr bool operator==(const expected & lhs, const unexpected<E2> & unex)
  {
    if (!lhs.has_val_) {
      return *lhs.error_ptr() == unex.error();
    }
    return false;
  }
  template <typename T2>
  friend constexpr bool operator==(const expected & lhs, const T2 & val)
  {
    if (lhs.has_val_) {
      return *lhs.value_ptr() == val;
    }
    return false;
  }

  friend constexpr void swap(expected & lhs, expected & rhs) noexcept(noexcept(lhs.swap(rhs)))
    requires requires { lhs.swap(rhs); }
  {
    lhs.swap(rhs);
  }
};

// The void partial specialization
template <typename T, typename E>
  requires std::is_void_v<T>
class expected<T, E>
{
  template <typename, typename>
  friend class expected;

  optional<E> unex_opt_;

public:
  using value_type = void;
  using error_type = E;
  using unexpect_type = unexpected<E>;

  template <typename U>
  using rebind = expected<U, error_type>;

  // constructors
  constexpr expected() = default;
  constexpr expected(const expected & other) = default;
  constexpr expected(expected && other) noexcept(std::is_nothrow_move_constructible_v<E>) = default;
  template <typename U, typename G>
  constexpr explicit(!std::is_convertible_v<const G &, E>) expected(const expected<U, G> & other)
    requires std::is_constructible_v<E, const G &> && std::is_void_v<U> &&
             (!std::is_convertible_v<unexpected<E>, expected<U, G> &> &&
              !std::is_convertible_v<unexpected<E>, expected<U, G>> &&
              !std::is_convertible_v<unexpected<E>, const expected<U, G> &> &&
              !std::is_convertible_v<unexpected<E>, const expected<U, G>>)
  {
    if (other.unex_opt_) {
      unex_opt_.emplace(other.error());
    }
  }
  template <typename U, typename G>
  constexpr explicit(!std::is_convertible_v<G, E>) expected(expected<U, G> && other)
    requires std::is_constructible_v<E, G> && std::is_void_v<U> &&
             (!std::is_convertible_v<unexpected<E>, expected<U, G> &> &&
              !std::is_convertible_v<unexpected<E>, expected<U, G>> &&
              !std::is_convertible_v<unexpected<E>, const expected<U, G> &> &&
              !std::is_convertible_v<unexpected<E>, const expected<U, G>>)
  {
    if (other.unex_opt_) {
      unex_opt_.emplace(std::move(other).error());
    }
  }
  template <typename G>
  constexpr explicit(!std::is_convertible_v<const G &, E>) expected(const unexpected<G> & e)
    requires std::is_constructible_v<E, const G &>
  {
    unex_opt_.emplace(e.error());
  }
  template <typename G>
  constexpr explicit(!std::is_convertible_v<G, E>) expected(unexpected<G> && e)
    requires std::is_constructible_v<E, G>
  {
    unex_opt_.emplace(std::move(e).error());
  }
  constexpr explicit expected(std::in_place_t) noexcept {}
  template <typename... Args>
  constexpr explicit expected(unexpect_t, Args &&... args)
    requires std::is_constructible_v<E, Args...>
  {
    unex_opt_.emplace(std::forward<Args>(args)...);
  }
  template <typename U, typename... Args>
  constexpr explicit expected(unexpect_t, std::initializer_list<U> ilist, Args &&... args)
    requires std::is_constructible_v<E, std::initializer_list<U> &, Args...>
  {
    unex_opt_.emplace(ilist, std::forward<Args>(args)...);
  }

  // destructor
  constexpr ~expected() = default;

  // assignment
  constexpr expected & operator=(const expected & other) = default;
  constexpr expected & operator=(expected && other) noexcept(
    std::is_nothrow_move_constructible_v<E> && std::is_nothrow_move_assignable_v<E>) = default;
  template <typename G>
  constexpr expected & operator=(const unexpected<G> & e)
    requires std::is_constructible_v<E, const G &> && std::is_assignable_v<E &, const G &>
  {
    unex_opt_.emplace(e.error());
    return *this;
  }
  template <typename G>
  constexpr expected & operator=(unexpected<G> && e)
    requires std::is_constructible_v<E, G> && std::is_assignable_v<E &, G>
  {
    unex_opt_.emplace(std::move(e).error());
    return *this;
  }

  // observers
  constexpr void operator*() const noexcept {}
  constexpr explicit operator bool() const noexcept { return !unex_opt_.has_value(); }
  constexpr bool has_value() const noexcept { return !unex_opt_.has_value(); }
  constexpr void value() const & noexcept {}
  constexpr void value() && noexcept {}
  constexpr const E & error() const & noexcept { return unex_opt_.value(); }
  constexpr E & error() & noexcept { return unex_opt_.value(); }
  constexpr const E && error() const && noexcept = delete;
  constexpr E && error() && noexcept { return std::move(unex_opt_).value(); }
  template <typename G = E>
  constexpr E error_or(G && default_value) const &
  {
    return has_value() ? std::forward<G>(default_value) : error();
  }
  template <typename G = E>
  constexpr E error_or(G && default_value) &&
  {
    return has_value() ? std::forward<G>(default_value) : std::move(error());
  }

  // monadic operations
  template <typename F>
  constexpr auto and_then(F && f) const &
    requires std::is_constructible_v<E, decltype(error())>
  {
    using result_t = std::remove_cvref_t<std::invoke_result_t<F>>;
    if (has_value()) {
      return std::invoke(std::forward<F>(f));
    }
    return result_t(unexpect, error());
  }
  template <typename F>
  constexpr auto and_then(F && f) &
    requires std::is_constructible_v<E, decltype(error())>
  {
    using result_t = std::remove_cvref_t<std::invoke_result_t<F>>;
    if (has_value()) {
      return std::invoke(std::forward<F>(f));
    }
    return result_t(unexpect, error());
  }
  template <typename F>
  constexpr auto and_then(F && f) const && = delete;
  template <typename F>
  constexpr auto and_then(F && f) &&
    requires std::is_constructible_v<E, decltype(std::move(error()))>
  {
    using result_t = std::remove_cvref_t<std::invoke_result_t<F>>;
    if (has_value()) {
      return std::invoke(std::forward<F>(f));
    }
    return result_t(unexpect, std::move(error()));
  }

  template <typename F>
  constexpr auto transform(F && f) const &
    requires std::is_constructible_v<E, decltype(error())>
  {
    using result_t = std::remove_cv_t<std::invoke_result_t<F>>;
    if (has_value()) {
      if constexpr (std::is_void_v<result_t>) {
        std::invoke(std::forward<F>(f));
        return expected<result_t, E>();
      } else {
        return expected<result_t, E>(std::in_place, std::invoke(std::forward<F>(f)));
      }
    }
    return expected<result_t, E>(unexpect, error());
  }
  template <typename F>
  constexpr auto transform(F && f) &
    requires std::is_constructible_v<E, decltype(error())>
  {
    using result_t = std::remove_cv_t<std::invoke_result_t<F>>;
    if (has_value()) {
      if constexpr (std::is_void_v<result_t>) {
        std::invoke(std::forward<F>(f));
        return expected<result_t, E>();
      } else {
        return expected<result_t, E>(std::in_place, std::invoke(std::forward<F>(f)));
      }
    }
    return expected<result_t, E>(unexpect, error());
  }
  template <typename F>
  constexpr auto transform(F && f) const && = delete;
  template <typename F>
  constexpr auto transform(F && f) &&
    requires std::is_constructible_v<E, decltype(std::move(error()))>
  {
    using result_t = std::remove_cv_t<std::invoke_result_t<F>>;
    if (has_value()) {
      if constexpr (std::is_void_v<result_t>) {
        std::invoke(std::forward<F>(f));
        return expected<result_t, E>();
      } else {
        return expected<result_t, E>(std::in_place, std::invoke(std::forward<F>(f)));
      }
    }
    return expected<result_t, E>(unexpect, std::move(error()));
  }

  template <typename F>
  constexpr auto or_else(F && f) const &
  {
    using result_t = std::remove_cvref_t<std::invoke_result_t<F, decltype(error())>>;
    if (has_value()) {
      return result_t();
    }
    return std::invoke(std::forward<F>(f), error());
  }
  template <typename F>
  constexpr auto or_else(F && f) &
  {
    using result_t = std::remove_cvref_t<std::invoke_result_t<F, decltype(error())>>;
    if (has_value()) {
      return result_t();
    }
    return std::invoke(std::forward<F>(f), error());
  }
  template <typename F>
  constexpr auto or_else(F && f) const && = delete;
  template <typename F>
  constexpr auto or_else(F && f) &&
  {
    using result_t = std::remove_cvref_t<std::invoke_result_t<F, decltype(std::move(error()))>>;
    if (has_value()) {
      return result_t();
    }
    return std::invoke(std::forward<F>(f), std::move(error()));
  }

  template <typename F>
  constexpr auto transform_error(F && f) const &
  {
    using result_t = std::remove_cv_t<std::invoke_result_t<F, decltype(error())>>;
    if (has_value()) {
      return expected<void, result_t>();
    }
    return expected<void, result_t>(unexpect, std::invoke(std::forward<F>(f), error()));
  }
  template <typename F>
  constexpr auto transform_error(F && f) &
  {
    using result_t = std::remove_cv_t<std::invoke_result_t<F, decltype(error())>>;
    if (has_value()) {
      return expected<void, result_t>();
    }
    return expected<void, result_t>(unexpect, std::invoke(std::forward<F>(f), error()));
  }
  template <typename F>
  constexpr auto transform_error(F && f) const && = delete;
  template <typename F>
  constexpr auto transform_error(F && f) &&
  {
    using result_t = std::remove_cv_t<std::invoke_result_t<F, decltype(std::move(error()))>>;
    if (has_value()) {
      return expected<void, result_t>();
    }
    return expected<void, result_t>(unexpect, std::invoke(std::forward<F>(f), std::move(error())));
  }

  // modifiers
  constexpr void emplace() noexcept
  {
    unex_opt_.reset();
  }

  constexpr void swap(expected & other) noexcept(
    std::is_nothrow_move_constructible_v<E> && std::is_nothrow_swappable_v<E>)
    requires std::is_swappable_v<E> && std::is_move_constructible_v<E>
  {
    unex_opt_.swap(other.unex_opt_);
  }

  // non-member functions
  template <typename T2, typename E2>
    requires std::is_void_v<T2>
  friend constexpr bool operator==(const expected & lhs, const expected<T2, E2> & rhs)
  {
    if (!lhs.has_value() && !rhs.has_value()) {
      return lhs.error() == rhs.error();
    }
    return lhs.has_value() && rhs.has_value();
  }
  template <typename E2>
  friend constexpr bool operator==(const expected & lhs, const unexpected<E2> & unex)
  {
    if (!lhs.has_value()) {
      return lhs.error() == unex.error();
    }
    return false;
  }

  friend constexpr void swap(expected & lhs, expected & rhs) noexcept(noexcept(lhs.swap(rhs)))
    requires requires { lhs.swap(rhs); }
  {
    lhs.swap(rhs);
  }
};

namespace detail
{

template <typename T>
struct is_expected : std::false_type
{
};
template <typename T, typename E>
struct is_expected<expected<T, E>> : std::true_type
{
};
template <typename T>
inline constexpr bool is_expected_v = is_expected<T>::value;

}  // namespace detail

}  // namespace no_stl
