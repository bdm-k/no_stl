#pragma once

#include <optional>

namespace no_stl
{

template <typename T>
class optional;

namespace detail
{

template <typename T>
struct is_optional : std::false_type
{
};
template <typename T>
struct is_optional<optional<T>> : std::true_type
{
};
template <typename T>
inline constexpr bool is_optional_v = is_optional<T>::value;

}  // namespace detail

template <typename T>
class optional
{
  template <typename U>
  friend class optional;

  // relational operators (two optional objects)
  template <typename Tp, typename Up>
  friend constexpr bool operator==(const optional<Tp> &, const optional<Up> &);
  template <typename Tp, typename Up>
  friend constexpr bool operator!=(const optional<Tp> &, const optional<Up> &);
  template <typename Tp, typename Up>
  friend constexpr bool operator<(const optional<Tp> &, const optional<Up> &);
  template <typename Tp, typename Up>
  friend constexpr bool operator<=(const optional<Tp> &, const optional<Up> &);
  template <typename Tp, typename Up>
  friend constexpr bool operator>(const optional<Tp> &, const optional<Up> &);
  template <typename Tp, typename Up>
  friend constexpr bool operator>=(const optional<Tp> &, const optional<Up> &);
  template <typename Tp, std::three_way_comparable_with<Tp> Up>
  friend constexpr std::compare_three_way_result_t<Tp, Up> operator<=>(
    const optional<Tp> &, const optional<Up> &);

  // relational operators (an optional object with a nullopt)
  template <typename U>
  friend constexpr bool operator==(const optional<U> &, std::nullopt_t) noexcept;
  template <typename U>
  friend constexpr std::strong_ordering operator<=>(const optional<U> &, std::nullopt_t) noexcept;

  // relational operators (an optional object with a value)
  template <typename Tp, typename Up>
  friend constexpr bool operator==(const optional<Tp> &, const Up &);
  template <typename Up, typename Tp>
  friend constexpr bool operator==(const Up &, const optional<Tp> &);
  template <typename Tp, typename Up>
  friend constexpr bool operator!=(const optional<Tp> &, const Up &);
  template <typename Up, typename Tp>
  friend constexpr bool operator!=(const Up &, const optional<Tp> &);
  template <typename Tp, typename Up>
  friend constexpr bool operator<(const optional<Tp> &, const Up &);
  template <typename Up, typename Tp>
  friend constexpr bool operator<(const Up &, const optional<Tp> &);
  template <typename Tp, typename Up>
  friend constexpr bool operator<=(const optional<Tp> &, const Up &);
  template <typename Up, typename Tp>
  friend constexpr bool operator<=(const Up &, const optional<Tp> &);
  template <typename Tp, typename Up>
  friend constexpr bool operator>(const optional<Tp> &, const Up &);
  template <typename Up, typename Tp>
  friend constexpr bool operator>(const Up &, const optional<Tp> &);
  template <typename Tp, typename Up>
  friend constexpr bool operator>=(const optional<Tp> &, const Up &);
  template <typename Up, typename Tp>
  friend constexpr bool operator>=(const Up &, const optional<Tp> &);
  template <typename Tp, std::three_way_comparable_with<Tp> Up>
  friend constexpr std::compare_three_way_result_t<Tp, Up> operator<=>(
    const optional<Tp> &, const Up &);

  std::optional<T> opt_;

public:
  using value_type = T;

  // constructors
  constexpr optional() noexcept {}
  constexpr optional(std::nullopt_t) noexcept {}
  constexpr optional(const optional & other) = default;
  constexpr optional(optional && other) noexcept(std::is_nothrow_move_constructible<T>::value) =
    default;
  template <typename U>
  constexpr explicit(!std::is_convertible_v<const U &, T>) optional(const optional<U> & other)
    requires std::is_constructible_v<T, const U &> &&
             (std::is_same_v<std::remove_cv_t<T>, bool> ||
              (!std::is_constructible_v<T, optional<U> &> &&
               !std::is_constructible_v<T, const optional<U> &> &&
               !std::is_constructible_v<T, optional<U> &&> &&
               !std::is_constructible_v<T, const optional<U> &&> &&
               !std::is_convertible_v<optional<U> &, T> &&
               !std::is_convertible_v<const optional<U> &, T> &&
               !std::is_convertible_v<optional<U> &&, T> &&
               !std::is_convertible_v<const optional<U> &&, T>))
  : opt_(other.opt_)
  {
  }
  template <typename U>
  constexpr explicit(!std::is_convertible_v<U, T>) optional(optional<U> && other)
    requires std::is_constructible_v<T, U> && (std::is_same_v<std::remove_cv_t<T>, bool> ||
                                               (!std::is_constructible_v<T, optional<U> &> &&
                                                !std::is_constructible_v<T, const optional<U> &> &&
                                                !std::is_constructible_v<T, optional<U> &&> &&
                                                !std::is_constructible_v<T, const optional<U> &&> &&
                                                !std::is_convertible_v<optional<U> &, T> &&
                                                !std::is_convertible_v<const optional<U> &, T> &&
                                                !std::is_convertible_v<optional<U> &&, T> &&
                                                !std::is_convertible_v<const optional<U> &&, T>))
  : opt_(std::move(other.opt_))
  {
  }
  template <typename... Args>
  constexpr explicit optional(std::in_place_t, Args &&... args)
    requires std::is_constructible_v<T, Args...>
  : opt_(std::in_place, std::forward<Args>(args)...)
  {
  }
  template <typename U, typename... Args>
  constexpr explicit optional(std::in_place_t, std::initializer_list<U> ilist, Args &&... args)
    requires std::is_constructible_v<T, std::initializer_list<U> &, Args...>
  : opt_(std::in_place, ilist, std::forward<Args>(args)...)
  {
  }
  template <typename U = std::remove_cv_t<T>>
  constexpr explicit(!std::is_convertible_v<U, T>) optional(U && value)
    requires std::is_constructible_v<T, U> &&
             (!std::is_same_v<std::remove_cvref_t<U>, std::in_place_t>) &&
             (!std::is_same_v<std::remove_cvref_t<U>, optional<T>>) &&
             (!std::is_same_v<std::remove_cv_t<T>, bool> ||
              !detail::is_optional_v<std::remove_cvref_t<U>>)
  : opt_(std::forward<U>(value))
  {
  }

  // destructor
  constexpr ~optional() = default;

  // assignment
  constexpr optional & operator=(std::nullopt_t) noexcept
  {
    opt_ = std::nullopt;
    return *this;
  }
  constexpr optional & operator=(const optional & other) = default;
  constexpr optional & operator=(optional && other) noexcept(
    std::is_nothrow_move_assignable_v<T> && std::is_nothrow_move_constructible_v<T>) = default;
  template <typename U>
  constexpr optional & operator=(const optional<U> & other)
    requires(!std::is_constructible_v<T, optional<U> &>) &&
            (!std::is_constructible_v<T, const optional<U> &>) &&
            (!std::is_constructible_v<T, optional<U> &&>) &&
            (!std::is_constructible_v<T, const optional<U> &&>) &&
            (!std::is_convertible_v<optional<U> &, T>) &&
            (!std::is_convertible_v<const optional<U> &, T>) &&
            (!std::is_convertible_v<optional<U> &&, T>) &&
            (!std::is_convertible_v<const optional<U> &&, T>) &&
            (!std::is_assignable_v<T &, std::optional<U> &>) &&
            (!std::is_assignable_v<T &, const std::optional<U> &>) &&
            (!std::is_assignable_v<T &, std::optional<U> &&>) &&
            (!std::is_assignable_v<T &, const std::optional<U> &&>) &&
            std::is_constructible_v<T, const U &> && std::is_assignable_v<T &, const U &>
  {
    opt_ = other.opt_;
    return *this;
  }
  template <typename U>
  constexpr optional & operator=(optional<U> && other)
    requires(!std::is_constructible_v<T, optional<U> &>) &&
            (!std::is_constructible_v<T, const optional<U> &>) &&
            (!std::is_constructible_v<T, optional<U> &&>) &&
            (!std::is_constructible_v<T, const optional<U> &&>) &&
            (!std::is_convertible_v<optional<U> &, T>) &&
            (!std::is_convertible_v<const optional<U> &, T>) &&
            (!std::is_convertible_v<optional<U> &&, T>) &&
            (!std::is_convertible_v<const optional<U> &&, T>) &&
            (!std::is_assignable_v<T &, std::optional<U> &>) &&
            (!std::is_assignable_v<T &, const std::optional<U> &>) &&
            (!std::is_assignable_v<T &, std::optional<U> &&>) &&
            (!std::is_assignable_v<T &, const std::optional<U> &&>) &&
            std::is_constructible_v<T, U> && std::is_assignable_v<T &, U>
  {
    opt_ = std::move(other.opt_);
    return *this;
  }
  template <typename U = std::remove_cv_t<T>>
  constexpr optional & operator=(U && value)
    requires(!std::is_same_v<std::remove_cvref_t<U>, std::optional<T>>) &&
            std::is_constructible_v<T, U> && std::is_assignable_v<T &, U> &&
            (!std::is_scalar_v<T> || !std::is_same_v<std::decay_t<U>, T>)
  {
    opt_ = std::forward<U>(value);
    return *this;
  }

  // swap
  constexpr void swap(optional & other) noexcept(
    std::is_nothrow_move_constructible_v<T> && std::is_nothrow_swappable_v<T>)
  {
    opt_.swap(other.opt_);
  }

  // observers
  constexpr const T * operator->() const noexcept { return &(*opt_); }
  constexpr T * operator->() noexcept { return &(*opt_); }
  constexpr const T & operator*() const & noexcept { return *opt_; }
  constexpr T & operator*() & noexcept { return *opt_; }
  constexpr const T && operator*() const && noexcept = delete;
  constexpr T && operator*() && noexcept { return std::move(*opt_); }
  constexpr explicit operator bool() const noexcept { return static_cast<bool>(opt_); }
  constexpr bool has_value() const noexcept { return opt_.has_value(); }
  constexpr const T & value() const & noexcept { return *opt_; }
  constexpr T & value() & noexcept { return *opt_; }
  constexpr const T && value() const && noexcept = delete;
  constexpr T && value() && noexcept { return std::move(*opt_); }
  template <typename U = std::remove_cv_t<T>>
  constexpr T value_or(U && default_value) const &
  {
    return opt_.value_or(std::forward<U>(default_value));
  }
  template <typename U = std::remove_cv_t<T>>
  constexpr T value_or(U && default_value) &&
  {
    return opt_.value_or(std::forward<U>(default_value));
  }

  // modifiers
  constexpr void reset() noexcept { opt_.reset(); }
};

// deduction guide
template <typename T>
optional(T) -> optional<T>;

// relational operators (two optional objects)
template <typename T, typename U>
constexpr bool operator==(const optional<T> & lhs, const optional<U> & rhs)
{
  return lhs.opt_ == rhs.opt_;
}
template <typename T, typename U>
constexpr bool operator!=(const optional<T> & lhs, const optional<U> & rhs)
{
  return lhs.opt_ != rhs.opt_;
}
template <typename T, typename U>
constexpr bool operator<(const optional<T> & lhs, const optional<U> & rhs)
{
  return lhs.opt_ < rhs.opt_;
}
template <typename T, typename U>
constexpr bool operator<=(const optional<T> & lhs, const optional<U> & rhs)
{
  return lhs.opt_ <= rhs.opt_;
}
template <typename T, typename U>
constexpr bool operator>(const optional<T> & lhs, const optional<U> & rhs)
{
  return lhs.opt_ > rhs.opt_;
}
template <typename T, typename U>
constexpr bool operator>=(const optional<T> & lhs, const optional<U> & rhs)
{
  return lhs.opt_ >= rhs.opt_;
}
template <typename T, std::three_way_comparable_with<T> U>
constexpr std::compare_three_way_result_t<T, U> operator<=>(
  const optional<T> & lhs, const optional<U> & rhs)
{
  return lhs.opt_ <=> rhs.opt_;
}

// relational operators (an optional object with a nullopt)
template <typename T>
constexpr bool operator==(const optional<T> & opt, std::nullopt_t) noexcept
{
  return opt.opt_ == std::nullopt;
}
template <typename T>
constexpr std::strong_ordering operator<=>(const optional<T> & opt, std::nullopt_t) noexcept
{
  return opt.opt_ <=> std::nullopt;
}

// relational operators (an optional object with a value)
template <typename T, typename U>
constexpr bool operator==(const optional<T> & opt, const U & value)
{
  return opt.opt_ == value;
}
template <typename U, typename T>
constexpr bool operator==(const U & value, const optional<T> & opt)
{
  return value == opt.opt_;
}
template <typename T, typename U>
constexpr bool operator!=(const optional<T> & opt, const U & value)
{
  return opt.opt_ != value;
}
template <typename U, typename T>
constexpr bool operator!=(const U & value, const optional<T> & opt)
{
  return value != opt.opt_;
}
template <typename T, typename U>
constexpr bool operator<(const optional<T> & opt, const U & value)
{
  return opt.opt_ < value;
}
template <typename U, typename T>
constexpr bool operator<(const U & value, const optional<T> & opt)
{
  return value < opt.opt_;
}
template <typename T, typename U>
constexpr bool operator<=(const optional<T> & opt, const U & value)
{
  return opt.opt_ <= value;
}
template <typename U, typename T>
constexpr bool operator<=(const U & value, const optional<T> & opt)
{
  return value <= opt.opt_;
}
template <typename T, typename U>
constexpr bool operator>(const optional<T> & opt, const U & value)
{
  return opt.opt_ > value;
}
template <typename U, typename T>
constexpr bool operator>(const U & value, const optional<T> & opt)
{
  return value > opt.opt_;
}
template <typename T, typename U>
constexpr bool operator>=(const optional<T> & opt, const U & value)
{
  return opt.opt_ >= value;
}
template <typename U, typename T>
constexpr bool operator>=(const U & value, const optional<T> & opt)
{
  return value >= opt.opt_;
}
template <typename T, std::three_way_comparable_with<T> U>
constexpr std::compare_three_way_result_t<T, U> operator<=>(
  const optional<T> & opt, const U & value)
{
  return opt.opt_ <=> value;
}

// non-member functions
template <typename T>
constexpr void swap(optional<T> & lhs, optional<T> rhs) noexcept(noexcept(lhs.swap(rhs)))
  requires std::is_move_constructible_v<T> && std::is_swappable_v<T>
{
  lhs.swap(rhs);
}

template <typename T>
constexpr optional<std::decay_t<T>> make_optional(T && value)
{
  return optional<std::decay_t<T>>(std::forward<T>(value));
}
template <typename T, typename... Args>
constexpr optional<T> make_optional(Args &&... args)
  requires std::is_constructible_v<T, Args...>
{
  return optional<T>(std::in_place, std::forward<Args>(args)...);
}
template <typename T, typename U, typename... Args>
constexpr optional<T> make_optional(std::initializer_list<U> ilist, Args &&... args)
  requires std::is_constructible_v<T, std::initializer_list<U> &, Args...>
{
  return optional<T>(std::in_place, ilist, std::forward<Args>(args)...);
}

}  // namespace no_stl
